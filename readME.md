Общий план решения
Технологии:
Flask для backend-части.
Redis для хранения белого и черного списков токенов.
PyJWT для работы с JWT-токенами.
SQLite (или другая БД) для хранения информации о пользователях и их ролях.
Структура системы:
Белый список (в Redis): хранит активные токены, которые разрешены для доступа.
Черный список (в Redis): хранит токены, которые были отозваны (например, при выходе пользователя из системы).
Роли:
1-я роль: ограниченные права (например, только чтение).
2-я роль: расширенные права (например, чтение и запись).
JWT-токены:
Содержат информацию о пользователе (ID, роль).
Используются для аутентификации запросов.
Логика работы:
При авторизации пользователь получает JWT-токен, который добавляется в белый список.
При выходе (logout) токен перемещается в черный список.
При каждом запросе проверяется, находится ли токен в белом списке и не находится ли он в черном.
На основе роли пользователя определяется доступ к ресурсам.
Если токен устарел или отозван, он удаляется из белого списка и добавляется в черный.

Объяснение кода
Авторизация (/api/login):
Пользователь отправляет username и password.
Если учетные данные верны, создается JWT-токен с информацией о пользователе (ID, роль) и сроком действия.
Токен добавляется в белый список в Redis.
Выход (/api/logout):
Токен удаляется из белого списка и добавляется в черный список.
Проверка токена:
При каждом запросе к защищенному ресурсу токен проверяется:
Не находится ли он в черном списке.
Находится ли он в белом списке.
Не истек ли срок действия.
Если токен валиден, проверяется роль пользователя.
Роли:
role1: ограниченный доступ (например, только чтение).
role2: полный доступ (чтение и запись).
Очистка устаревших токенов (/api/cleanup):
Проверяет все токены в белом списке.
Если токен устарел, он удаляется из белого списка и добавляется в черный.
Дополнительные задачи
Белый список взаимодействия с контентом:
Хранится в Redis как множество (whitelist).
Токены добавляются при авторизации.
Определить возможности учетки токенов:
Роль извлекается из JWT-токена и используется для определения прав доступа.
Реализовать систему ролей:
Реализовано через поле role в JWT-токене и проверку в защищенных маршрутах.
Указывать дальнейшее решение (удаление токена):
Реализовано через маршрут /api/logout и очистку устаревших токенов (/api/cleanup).
P.S. Клиентская часть
Клиентская часть может быть реализована, например, на JavaScript с использованием фреймворка (React, Vue.js) или просто с помощью HTML/JS. Она должна:

Отправлять запросы на /api/login для получения токена.
Сохранять токен (например, в localStorage).
Добавлять токен в заголовок Authorization для защищенных запросов.
Обрабатывать выход через запрос на /api/logout.

Шаг 2: Сборка и запуск контейнеров
Убедитесь, что Docker и Docker Compose установлены:

Установите Docker: инструкция
Установите Docker Compose: инструкция
Соберите и запустите контейнеры:
В корневой директории проекта выполните:

bash

Collapse

Wrap

Copy
docker-compose up --build
Это создаст два контейнера:
app — Flask-приложение.
redis — Redis-сервер.
Flask будет доступен по адресу http://localhost:5000.
Проверка работы:

Отправьте POST-запрос на /api/login для авторизации:
bash

Collapse

Wrap

Copy
curl -X POST http://localhost:5000/api/login -H "Content-Type: application/json" -d '{"username": "user1", "password": "pass1"}'
Ожидаемый ответ:
json

Collapse

Wrap

Copy
{"token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."}
Используйте полученный токен для доступа к защищенному ресурсу:
bash

Collapse

Wrap

Copy
curl http://localhost:5000/api/protected -H "Authorization: <your-token>"
Ожидаемый ответ:
json

Collapse

Wrap

Copy
{"message": "You have read-only access (role1)"}
Выполните выход:
bash

Collapse

Wrap

Copy
curl -X POST http://localhost:5000/api/logout -H "Authorization: <your-token>"
Ожидаемый ответ:
json

Collapse

Wrap

Copy
{"message": "Logged out successfully"}
Шаг 3: Дополнительные замечания
Хранение данных:
SQLite база данных (users.db) создается автоматически в контейнере и сохраняется благодаря монтированию тома через volumes в docker-compose.yml.
Данные Redis также сохраняются в томе redis-data.
Масштабируемость:
Для продакшена рекомендуется использовать более надежную базу данных (например, PostgreSQL) вместо SQLite.
Можно настроить переменные окружения для SECRET_KEY и других конфигураций.
Остановка контейнеров: Чтобы остановить контейнеры, выполните:
bash

Collapse

Wrap

Copy
docker-compose down
Публикация образа (опционально): Если вы хотите опубликовать образ в Docker Hub:
Соберите образ:
bash

Collapse

Wrap

Copy
docker build -t yourusername/flask-auth-app .
Залогиньтесь в Docker Hub:
bash

Collapse

Wrap

Copy
docker login
Опубликуйте образ:
bash

Collapse

Wrap

Copy
docker push yourusername/flask-auth-app

Шаг 5: Тестирование
Авторизация:
Введите username: user1 и password: pass1 (или user2 и pass2).
Нажмите "Login".
Если авторизация успешна, вы увидите сообщение "Login successful!" и кнопка "Logout" станет активной.
Доступ к защищенному ресурсу:
Нажмите "Get Protected Data".
Если токен валиден, вы увидите сообщение, например, "You have read-only access (role1)" для user1.
Выход:
Нажмите "Logout".
Токен будет удален из localStorage, и вы увидите сообщение "Logout successful!".
Дополнительные замечания
Безопасность:
В продакшене рекомендуется использовать HTTPS для защиты токенов.
Пароли в базе данных должны быть захешированы (в примере они хранятся в открытом виде для простоты).
Стили:
CSS в index.html минималистичный. Вы можете улучшить дизайн, добавив больше стилей.
Обработка ошибок:
JavaScript-код включает базовую обработку ошибок. Вы можете добавить более детализированные сообщения или логирование.